<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Blob</title>
    <style>
        body, html {
            margin: 0;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <!-- Vertex Shader -->
    <script id="vertexShader" type="x-shader/x-vertex">
        #version 300 es
        in vec2 a_position;
        out vec2 v_position;

        void main() {
            v_position = a_position;
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader (animated color effect) -->
    <script id="fragmentShader" type="x-shader/x-fragment">
        #version 300 es
        precision mediump float;
        
        in vec2 v_position;
        uniform vec2 u_resolution;
        uniform float u_time;
        out vec4 outColor;
        
        const int MAX_STEPS = 80;
        const int NUM_BALLS = 15;
        const float EPSILON = 0.01;
        const float MAX_DIST = 100.0;
        
        // Reflection parameters
        const int MAX_REFLECTIONS = 2;       // Maximum number of reflections
        const float REFLECTION_FACTOR = 0.1; // Intensity of reflections

        // Ambient Occlusion parameters
        const int AO_SAMPLES = 32;
        const float AO_STEP = 0.02;
        const float AO_SCALE = 0.9;
        
        // Shadows parameters
        const float SHADOW_BIAS = 1.0; 
        const int SHADOW_STEPS = 64;
        const float SHADOW_EPSILON = 0.005;
        const float SHADOW_INTENSITY = 0.1;
        
        // PCF Soft Shadow parameters
        const int PCF_SAMPLES = 2;
        const float PCF_OFFSET = 0.05;
        
        // Ambient Light
        const float AMBIENT_LIGHT = 0.15;
        
        // Chromatic Aberration Offset
        const float ABERRATION_AMOUNT = 0.008;
        
        vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
            return a + b * cos(6.28318 * (c * t * d));
        }
        
        vec3 palette_fixed(float t) {
            vec3 a = vec3(0.5, 0.5, 0.5);
            vec3 b = vec3(0.5, 0.5, 0.5);
            vec3 c = vec3(1.0, 0.7, 0.4);
            vec3 d = vec3(0.0, 0.15, 0.2);
            return palette(t, a, b, c, d);
        }
        
        vec2 rot2d(vec2 v, float angle) {
            float cosa = cos(angle);
            float sina = sin(angle);
            
            mat2 rotation = mat2(
                cosa, -sina,
                sina,  cosa
            );
            
            return rotation * v;
        }
        
        float sphere(vec3 p, float r) {
            return length(p) - r;
        }
        
        float smoothUnion(float d1, float d2, float k) {
            float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);
            return mix(d2, d1, h) - k * h * (1.0 - h);
        }
        
        float dist(vec3 p) {
            float t = u_time * 0.7;
            float r = 0.7;
            float scale = 0.7;
            float k = 0.7;
            
            // rotate p in xz-plane
            p.xz = rot2d(p.xz, t + p.y * 2.0 * sin(t) * sin(p.y * 0.5 + t * 2.0));

            // rotate p in yz - plane
            p.yz = rot2d(p.yz, t * 0.5 + p.x * 0.1);

            float j = 0.5;
            vec3 pos = vec3(sin(t * 0.3 * j + j) * 1.2 + cos(t + j), 
                           sin(t * 0.2 * j + j) * 2.0, 
                           sin(t + j) * 1.7 + j * 0.5) * scale;
            float s = sphere(p - pos, r);
        
            for (int i = 0; i < NUM_BALLS - 1; i++) {
                j = float(i);
                pos = vec3(sin(t * 0.3 * j + j) * 1.2 + cos(t + j), 
                           sin(t * 0.2 * j + j) * 2.0, 
                           sin(t + j) * 1.7 + 1.0) * scale;
                float s1 = sphere(p - pos, r + sin(t + j * 2.0) * 0.3 + sin(t * 3.0 + j * 0.8) * 0.2);
                s = smoothUnion(s, s1, k);
            }
        
            return s;
        
            // Uncomment if you want a floor plane
            // float floor = p.y + 2.5;
            // return min(floor, s);
        }

        vec3 calcNormal(in vec3 p)
        {
            const vec2 h = vec2(EPSILON,0);
            return normalize(vec3(dist(p+h.xyy) - dist(p-h.xyy),
                                  dist(p+h.yxy) - dist(p-h.yxy),
                                  dist(p+h.yyx) - dist(p-h.yyx)));
        }

        vec3 calcFastNormal(in vec3 p, float d)
        {
            const vec2 h = vec2(EPSILON,0);
            return normalize(vec3(dist(p+h.xyy) - d,
                                  dist(p+h.yxy) - d,
                                  dist(p+h.yyx) - d));
        }

        vec3 calcFastNormal2( in vec3 p ) 
        {
            const vec2 k = vec2(1,-1);
            return normalize(k.xyy*dist( p + k.xyy*EPSILON ) + 
                            k.yyx*dist( p + k.yyx*EPSILON ) + 
                            k.yxy*dist( p + k.yxy*EPSILON ) + 
                            k.xxx*dist( p + k.xxx*EPSILON ) );
        }
        
        float ambientOcclusion(vec3 p, vec3 normal) {
            float oc = 0.0;
            
            float t = SHADOW_BIAS * 0.5;
            for(int i = 1; i <= AO_SAMPLES; i++) {
                float d = dist(p + normal * t);
                oc += clamp((t - d) / t, 0.0, 1.0);
                t += AO_STEP;
            }

            float ao = 1.0 - (oc / float(AO_SAMPLES)) * AO_SCALE;
            return clamp(ao, 0.0, 1.0);
        }
        
        // Hard Shadow Function
        float hardShadow(vec3 p, vec3 lightDir) {
            float t = SHADOW_BIAS; // Start above the surface
            for(int i = 0; i < SHADOW_STEPS; i++) {
                vec3 pos = p + lightDir * t;
                float d = dist(pos);
                if(d < SHADOW_EPSILON) {
                    return SHADOW_INTENSITY; // In shadow
                }
                t += d;
                if(t > MAX_DIST) break; // Exceeded max distance
            }
            return 1.0; // Fully lit
        }
        
        // Soft Shadow Function using SDF-based Raymarching
        float softShadow(vec3 p, vec3 lightDir) {
            float k = 7.0;

            float t = SHADOW_BIAS; // Start above the surface
            float res = 1.0;
            for(int i = 0; i < SHADOW_STEPS; i++) {
                vec3 pos = p + lightDir * t;

                float d = dist(pos);
                if(d < SHADOW_EPSILON) {
                    return SHADOW_INTENSITY; // In shadow
                }
                res = min(res, k*d/t);
                t += d;
                if(t > MAX_DIST) break; // Exceeded max distance
            }
            return max(res, SHADOW_INTENSITY);
        }
        
        // PCF Soft Shadow Function
        float pcfHardShadow(vec3 p, vec3 lightDir) {
            float shadow = 0.0;
            int samples = PCF_SAMPLES;
            float offset = PCF_OFFSET;
        
            for(int x = -samples; x <= samples; x++) {
                for(int y = -samples; y <= samples; y++) {
                    // Perturb light direction
                    vec3 perturbedDir = normalize(lightDir + vec3(float(x) * offset, float(y) * offset, 0.0));
                    shadow += hardShadow(p, perturbedDir);
                }
            }
        
            // Average the shadow results
            shadow /= float((samples * 2 + 1) * (samples * 2 + 1));
            return shadow;
        }

        // Raymarching function with iterative reflection
        vec3 raymarch2(vec2 uv, vec3 ro, vec3 rd) {
            vec3 col = vec3(0.0);
            vec3 accumulatedColor = vec3(0.0);
            vec3 currentOrigin = ro;
            vec3 currentDir = rd;
            float reflectionContribution = 1.0;
            
            for(int reflection = 0; reflection <= MAX_REFLECTIONS; reflection++) {
                float t = 0.0; // Total distance traveled
                bool hit = false;
                vec3 hitPoint;
                vec3 normal;
                
                // Perform raymarching
                for (int i = 0; i < MAX_STEPS; i++) {
                    vec3 p = currentOrigin + currentDir * t;
                    float d = dist(p); // Distance to scene
                    if (d < EPSILON) {
                        hit = true;
                        hitPoint = p;
                        
                        // Compute normals using central differences
                        normal = calcFastNormal(p, d);
                        break;
                    }
                    t += d; // Step along the ray
                    if(t > MAX_DIST) break;
                }
                
                if(hit) {
                    // Compute Ambient Occlusion
                    float ao = ambientOcclusion(hitPoint, normal);
        
                    //return vec3(ao);

                    // Define Light Direction
                    vec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));
            
                    // Compute Shadows
                    float sh = softShadow(hitPoint, lightDir);

                    //return vec3(sh);

                    // Define diffuse Color
                    vec3 diffuseColor = vec3(0.8, 0.6, 0.9);

                    // Compute Lighting (Diffuse)
                    float lighting = max(dot(normal, lightDir), 0.0);
            
                    // Compute Specular Lighting using Blinn-Phong
                    vec3 viewDir = normalize(currentOrigin - hitPoint);
                    vec3 halfVector = normalize(lightDir + viewDir);
                    float specAngle = max(dot(halfVector, normal), 0.0);
                    float specular = pow(specAngle, 32.0); // Shininess factor
            
                    // Define Specular Color
                    vec3 specularColor = vec3(0.8, 0.6, 0.9);
            
                    // Combine Specular with Lighting and Shadows
                    float spec = specular * sh;
            
                    // Define Albedo (Base Color)
                    vec3 albedo = palette_fixed(length(t * 2.0) * sin(u_time * 0.5));
            
                    // Combine Diffuse, Specular, and Ambient
                    vec3 diffuse = diffuseColor * lighting * albedo * sh;
                    vec3 finalSpecular = specularColor * spec * 0.7;
                    vec3 ambient = AMBIENT_LIGHT * ao * albedo;
            
                    // Local color at hit point
                    vec3 localColor = diffuse + finalSpecular + ambient;
            
                    // Accumulate color with reflection contribution
                    accumulatedColor += localColor * reflectionContribution;
            
                    // Prepare for reflection
                    if(reflection < MAX_REFLECTIONS) {
                        // Compute reflection direction
                        currentDir = reflect(currentDir, normal);
                        
                        // Offset the origin to prevent self-intersection
                        currentOrigin = hitPoint + normal * EPSILON * 2.0;
                        
                        // Update reflection contribution
                        reflectionContribution *= REFLECTION_FACTOR;
                    }
                } else {
                    // No hit, accumulate background color
                    vec3 backgroundColor = vec3(0.05, 0.05, 0.2) - vec3(0.15, 0.15, 0.3) * uv.y;
                    accumulatedColor += backgroundColor * reflectionContribution;
                    break;
                }
            }
            
            col = accumulatedColor;
            return col;
        }

        // Raymarching function for chromatic aberration
        vec3 raymarch(vec2 uv) {
            vec3 ro = vec3(0.0, 0.0, -5.0);         // Ray origin
            vec3 rd = normalize(vec3(uv, 1.0));     // Ray direction

            //return rd;

            return raymarch2(uv, ro, rd);
        }

       
        void main() {
            vec2 uv = v_position;
            uv.x *= u_resolution.x / u_resolution.y;

            // Define chromatic offsets for each color channel
            //vec2 offsetR = vec2(-ABERRATION_AMOUNT, 0.0); // Red shifted left
            //vec2 offsetG = vec2(0.0, 0.0);                 // Green no shift
            //vec2 offsetB = vec2(ABERRATION_AMOUNT, 0.0);  // Blue shifted right
        
            // Compute color for each channel
            //float r = raymarch(uv + offsetR).r;
            //float g = raymarch(uv + offsetG).g;
            //float b = raymarch(uv + offsetB).b;
        
            // Combine channels into final color
            //vec3 col = vec3(r, g, b);
        
            vec3 col = raymarch(uv);

            outColor = vec4(col, 1.0);
        }
    </script>

    <script type="text/javascript">
        // Get the canvas element
        const canvas = document.getElementById('glCanvas');

        // Set the canvas to full window size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Initialize the WebGL2 context with anti-aliasing enabled
        const gl = canvas.getContext('webgl2', { antialias: true });

        if (!gl) {
            console.error('WebGL2 not supported, please use a modern browser.');
        }

        // Function to get shader source from the script tags
        function getShaderSource(id) {
            return document.getElementById(id).textContent.trim();
        }

        // Function to compile a shader
        function compileShader(gl, shaderSource, shaderType) {
            const shader = gl.createShader(shaderType);
            gl.shaderSource(shader, shaderSource);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation failed:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
            }
            return shader;
        }

        // Function to create the shader program
        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = compileShader(gl, vertexSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fragmentSource, gl.FRAGMENT_SHADER);

            if (!vertexShader || !fragmentShader) {
                console.error('Shader creation failed.');
            }

            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Program linking failed:', gl.getProgramInfoLog(shaderProgram));
                gl.deleteProgram(shaderProgram);
            }
            return shaderProgram;
        }

        // Get shader sources from the script tags
        const vertexShaderSource = getShaderSource('vertexShader');
        const fragmentShaderSource = getShaderSource('fragmentShader');

        // Create the shader program
        const shaderProgram = createShaderProgram(gl, vertexShaderSource, fragmentShaderSource);

        if (!shaderProgram) {
            console.error('Shader program creation failed.');
        }

        // Look up attribute locations
        const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');

        // Create a buffer and put a quad that covers the entire canvas
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

        // Define two triangles to cover the entire screen
        const positions = new Float32Array([
            -1.0, -1.0,
             1.0, -1.0,
            -1.0,  1.0,
            -1.0,  1.0,
             1.0, -1.0,
             1.0,  1.0,
        ]);

        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        // Setup position attribute for WebGL2
        gl.enableVertexAttribArray(positionAttributeLocation);

        gl.vertexAttribPointer(
            positionAttributeLocation,  // Attribute location
            2,                          // Number of components per vertex (2 for x, y)
            gl.FLOAT,                   // Type of data (32-bit float)
            false,                      // Normalize?
            0,                          // Stride (0 = move forward size * sizeof(type))
            0                           // Offset (start at beginning of buffer)
        );

        // Look up the location of the uniform variable "u_time"
        const timeUniformLocation = gl.getUniformLocation(shaderProgram, 'u_time');
        const resolutionUniformLocation = gl.getUniformLocation(shaderProgram, 'u_resolution');

        // Resize canvas and viewport when window size changes
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Render function
        function render(time) {
            // Clear the canvas
            gl.clearColor(0.0, 0.0, 0.0, 1.0); // Clear to black
            gl.clear(gl.COLOR_BUFFER_BIT);

            // Use the shader program
            gl.useProgram(shaderProgram);

            // Pass the current time to the shader (in seconds)
            gl.uniform1f(timeUniformLocation, time * 0.001); // Convert time to seconds
             // Pass the canvas resolution to the shader
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

            // Draw the triangles
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // Request the next frame
            requestAnimationFrame(render);
        }

        // Start rendering with the animation
        requestAnimationFrame(render);
    </script>
</body>
</html>
